using UnityEngine;
using System.Collections;

public class WorldPointsMovement : MonoBehaviour {

	public GameObject[] waypoints;
	private Vector3[] points;
	public bool moveYAxis = false;
	public float velocity = 0.5f;
	public float rotationSpeed = 3f;
	private int vectorIndex = 0;
	private Vector3 startPoint;
	public float minDistanceToChangePoint = 1f;
	//private float distanceMoved = 0f;

	private Rigidbody enemyRigidbody;
	//EnemyCollisions enemyCollisions;
	
	// Use this for initialization
	void Awake () {
		//startPosition = transform.localPosition;
		//enemyCollisions = gameObject.GetComponent<EnemyCollisions>();

		points = new Vector3[waypoints.Length];

		for(int i=0; i<waypoints.Length; i++ ){
			if(!moveYAxis){
				points[i] = new Vector3(waypoints[i].transform.position.x, transform.position.y, waypoints[i].transform.position.z);
			}else{
				points[i] = new Vector3(waypoints[i].transform.position.x, waypoints[i].transform.position.y, waypoints[i].transform.position.z);
			}
		}

		enemyRigidbody = GetComponent<Rigidbody>();
		startPoint = transform.position;
	}
	
	/*
	void FixedUpdate () {
		Movement(transform.position, points[vectorIndex], velocity);
	}
	*/

	void Update(){
		Movement(transform.position, new Vector3(points[vectorIndex].x,transform.position.y,points[vectorIndex].z), velocity);
	}

	
	void Movement(Vector3 start, Vector3 end, float velocity){

		//distanceMoved += (1.0f/velocity) * Time.deltaTime;

		FlipWithSpeed(end, rotationSpeed);

		/*
		if(distanceMoved >= 1){
			distanceMoved = 0;
		}
		*/

		enemyRigidbody.MovePosition( Vector3.Lerp(start, end, velocity * Time.deltaTime) );

		if( Vector3.Distance(transform.position, end) <= minDistanceToChangePoint ){
			if(vectorIndex < points.Length-1){
				startPoint = transform.position;
				vectorIndex++;
			}else{
				startPoint = transform.position;
				vectorIndex = 0;
			}
		}
	}
	
	void FlipWithSpeed(Vector3 end, float speed){
		Quaternion finalRotation = Quaternion.LookRotation(end - transform.position);

		if( Mathf.Round(transform.rotation.eulerAngles.y) != Mathf.Round(finalRotation.eulerAngles.y)){
			transform.rotation = Quaternion.Euler(0f, Quaternion.Slerp(transform.rotation, finalRotation, Time.deltaTime * speed).eulerAngles.y, 0f);
		}
	}
}
